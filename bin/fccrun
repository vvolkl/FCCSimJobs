#!/usr/bin/env python2

import os
import sys
import argparse
from tempfile import mkstemp



# these default properties are filtered as otherwise they will clutter the argument list
GaudiProps = [ "ContextService", "Cardinality", "Context", "CounterList", "EfficiencyRowFormat",
  "Enable", "ErrorCount", "ErrorMax", "ErrorsPrint", "ExtraInputs", "ExtraOutputs",
  "FilterCircularDependencies", "StatEntityList", "IsIOBound", "MonitorService", "NeededResources",
  "PropertiesPrint", "RegisterForContextService", "RegularRowFormat", "RequireObjects", "RootInTES",
  "StatPrint", "StatTableHeader", "Timeline", "TypePrint", "UseEfficiencyRowFormat",
  "VetoObjects","OutputLevel",
  "EnableFaultHandler" ,"InhibitPathes" ,"EnableAccessHandler" ,"ForceLeaves" ,"RootName"
  ,"DataAccessName", "DataFaultName", "RootCLID"
  ]



#---------------------------------------------------------------------
if __name__ == "__main__":
    # ensure that we (and the subprocesses) use the C standard localization
    if os.environ.get('LC_ALL') != 'C':
        #print '# setting LC_ALL to "C"'
        os.environ['LC_ALL'] = 'C'

    # run all the configuration files
    for f in sys.argv[1:]:
      if f[0] != '-':
        execfile(f)

    from argparse import ArgumentParser
    parser = ArgumentParser(description="Run jobs in the main FCC framework")
    parser.add_argument("config_files", nargs="+",
                      help="gaudi config.py files")
    parser.add_argument("--dry-run", action="store_true",
                      help="do not run the application, just parse option files")
    parser.add_argument("-v", "--verbose", action="store_true",
                      help="print the parsed options")
    parser.add_argument("-l", "--list", action="store_true",
                      help="print all the option (even if equal to default)")
    parser.add_argument("--gdb", action="store_true", help="attach gdb debugger")
    # GaudiPython Parallel Mode Option
    #   Argument must be an integer in range [ -1, sys_cpus ]
    #   -1   : All available cpus
    #    0   : Serial Mode (traditional gaudirun)
    #    n>0 : parallel with n cpus (n <= sys_cpus)
    parser.add_argument("--ncpus",  type=int, default=0,
                      help="start the application in parallel mode using NCPUS processes. "
                           "0 => serial mode (default), -1 => use all CPUs")


    for alg in ApplicationMgr().TopAlg:
      print ' --> ', alg.name(), 
    print "",'\n'

    for conf in ApplicationMgr.allConfigurables.values():
      if "ToolSvc" not in conf.name() and "ApplicationMgr" not in conf.name():
        props = conf.getPropertiesWithDescription()
        for prop in props:
          if not prop in GaudiProps:
            if not "Audit" in prop:
              print conf.name(), prop, props[prop]
              try:
                parser.add_argument("--" + prop, type=str, help=props[prop][1])
              except argparse.ArgumentError:
                pass




    #opts, unknown = parser.parse_known_args() #this is an 'internal' method
    # which returns 'parsed', the same as what parse_args() would return
    # and 'unknown', the remainder of that
    # the difference to parse_args() is that it does not exit when it finds redundant arguments



    #for arg in unknown:
    #    if arg.startswith(("-", "--")):
            #you can pass any arguments to add_argument

    opts=parser.parse_args()
    #print opts





    # Parallel Option ---------------------------------------------------------
    if opts.ncpus:
        from multiprocessing import cpu_count
        sys_cpus = cpu_count()
        if opts.ncpus > sys_cpus:
            s = "Invalid value : --ncpus : only %i cpus available" % sys_cpus
            parser.error(s)
        elif opts.ncpus < -1:
            s = "Invalid value : --ncpus must be integer >= -1"
            parser.error(s)

    # configure the logging
    import logging
    from GaudiKernel.ProcessJobOptions import (InstallRootLoggingHandler,
                                               PrintOff)

    prefix = "# "
    level = logging.INFO
    if opts.verbose:
        level = logging.VERBOSE
    InstallRootLoggingHandler(prefix, level=level, with_time=opts.verbose)
    root_logger = logging.getLogger()





    from Gaudi.Main import gaudimain
    c = gaudimain()
    if not opts.dry_run:
        # Do the real processing
        retcode = c.run(opts.gdb, opts.ncpus)
        sys.exit(retcode)
